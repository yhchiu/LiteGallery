# 影片縮放 (Video Zoom) 不同實現方式分析

本文檔旨在分析和比較在 Android 中實現影片縮放功能的三種主要技術方法：`View.scaleX/scaleY`、`TextureView + setTransform`，以及 Media3 的 `Effect` API。

## 比較總表

| 特性 | `View.scaleX`/`scaleY` | `TextureView` + `setTransform` | Media3 `Effect` |
| :--- | :--- | :--- | :--- |
| **實現原理** | 修改 `PlayerView` (作為一個整體 View) 的繪製屬性，拉伸整個 View。 | 通過 Matrix 修改 `TextureView` 的變換，`TextureView` 本身可被視為一個圖形紋理。 | 在 GPU 中通過 Shader 修改影片影格的紋理座標 (Texture Coordinates) 來實現畫面內容的縮放。 |
| **性能** | **中等**。View 變換是硬體加速的，但縮放整個 View 仍有開銷。 | **中等偏低**。`TextureView` 比 `SurfaceView` 有更高的延遲和功耗。 | **高**。直接在 GPU 渲染管線中處理，開銷極小，是最高效的方式。 |
| **縮放品質** | **低**。純粹的像素拉伸，放大後畫面容易模糊、產生鋸齒。 | **中等**。品質取決於 Matrix 的設定，但仍是基於 View 的拉伸。 | **高**。真正的數位縮放，重新對源影片紋理採樣，可以得到更清晰的結果。 |
| **耗電量** | **低**。接近基礎播放功耗，View 變換的額外開銷不大。 | **高**。`TextureView` 的繪製和合成機制有較高的固定功耗。 | **低**。GPU 內高效處理，額外功耗極低。 |
| **對 UI 控制項的影響** | **會影響**。這是最主要缺點，整個 `PlayerView`（包括所有按鈕、進度條）都會被放大。 | **會影響**。如果 UI 控制項是 `TextureView` 的子 View，會一起被變換。 | **無影響**。只處理影片內容，UI 控制項保持原樣，體驗最好。 |
| **實作複雜度** | **低**。最簡單的方式，與 `ScaleGestureDetector` 完美結合。 | **高**。需要手動管理 Matrix，並且要強制 Player 使用 `TextureView`。 | **高**。需要編寫 GLSL Shader 和相應的 `Effect` 類，學習曲線最陡峭。 |
| **優點** | - 極其簡單，程式碼量最少<br>- 開發者最熟悉的方式 | - 可實現旋轉、傾斜等複雜變換<br>- 像普通 View 一樣可做透明和動畫 | - 性能最好<br>- 縮放品質最高<br>- 不影響 UI 控制項<br>- 可與其他效果（亮度等）合併處理 |
| **缺點** | - 縮放品質差<br>- 會放大 UI 控制項，影響體驗 | - 性能和功耗是主要問題<br>- 實作複雜 | - 實作最複雜，需要 GLSL 知識 |
| **最適用情境** | 快速實現功能原型，或對縮放品質和 UI 體驗要求不高的簡單應用。 | 需要對影片進行複雜 2D/3D 變換或動畫的特殊場景。 | 對性能、畫質和使用者體驗有較高要求的專業級媒體瀏覽器或播放器。 |

---

## 詳細解釋

### 1. `View.scaleX`/`scaleY` (最簡單，但品質最差)

這是最直接的方法。`PlayerView` 本身就是一個 Android `View`，你可以像操作任何按鈕或文字一樣，用 `setScaleX()` 和 `setScaleY()` 來縮放它。

*   **工作方式：** 想像一下你用 Photoshop 把一張圖片的長寬都設為 200%。Android 的 `View` 縮放做的是類似的事情，它告訴 GPU：「把這個 View 已經畫好的內容，當作一張圖，然後把它拉伸到指定大小再畫到螢幕上」。
*   **致命缺點：**
    1.  **品質損失：** 因為是「先畫好再拉伸」，所以放大後只是單純地把像素點變大，畫面會變得模糊和塊狀化。
    2.  **UI 災難：** 它縮放的是 `PlayerView` 這個**容器**。如果你的播放/暫停按鈕、進度條是 `PlayerView` 的一部分，它們會跟著影片一起被放大，變得巨大且模糊，使用者體驗很差。

### 2. `TextureView` + `setTransform` (靈活，但犧牲性能)

這個方法放棄了 Media3 預設的 `SurfaceView`，轉而使用 `TextureView`。

*   **工作方式：** `TextureView` 將影片內容作為一個紋理（Texture）交給 View 系統管理。`setTransform()` 接受一個 `Matrix`（矩陣），你可以用這個矩陣精確地告訴 `TextureView` 如何對它的內容進行移動、縮放、旋轉。
*   **為什麼要用它：** 因為 `TextureView` 的行為和普通 View 完全一樣，你可以對它做各種複雜的動畫和變形，而 `SurfaceView` 做不到。
*   **致命缺點：**
    1.  **性能代價：** `TextureView` 為了實現這種靈活性，引入了額外的緩衝和合成步驟，這會導致**更高的延遲**和**更多的功耗**。對於高解析度或高影格率的影片，這可能導致掉影格或影音不同步。你為了縮放功能，犧牲了最核心的播放流暢度。

### 3. Media3 `Effect` (最專業，但最複雜)

這是 Media3 推薦的影片處理方式，也是最接近底層原理的方式。

*   **工作方式：** 它在影片解碼後、渲染到螢幕前的最後一刻介入。它拿到的是原始的影片影格紋理。你通過 GLSL Shader 告訴 GPU：「不要直接把整個紋理畫到螢幕上，而是只取紋理中間 50% 的區域 (`texCoord * 0.5 + 0.25`)，然後把這個小區域的內容拉伸，填滿整個螢幕區域」。
*   **優點的根源：**
    1.  **高品質：** 這是真正的「數位變焦」。因為它操作的是原始的、未經拉伸的影片源，所以可以通過演算法（預設是線性插值）計算出更精確的像素顏色，得到更清晰的放大效果。
    2.  **高性能：** 這個計算完全在 GPU 上完成，並且是整合在 Media3 原本的渲染流程中的，幾乎是「零成本」的附加操作。
    3.  **UI 獨立：** 它只操作影片影格，你的 UI 控制項位於 `PlayerView` 的另一個圖層，完全不受影響。

## LiteGallery App 實作建議

*   **快速實現方案 (當前可能採用的方式):** 使用 `View.scaleX/scaleY`。這與專案中已有的 `ZoomablePlayerView.kt` 等自訂 View 的思路吻合。此方案開發速度快，但需注意其對 UI 控制項的影響。**改良方法**是將 UI 控制項從 `PlayerView` 中分離出來，放到它的外部，避免一起被縮放。
*   **最佳體驗方案 (長期目標):** **`Media3 Effect` 是唯一能兼顧性能、畫質和 UI 體驗的方案**。雖然學習成本高，但它代表了更專業的實現，是高品質媒體瀏覽器應追求的標準。

建議可先沿用或改良現有的 View 縮放方案以快速迭代，並在後續版本中投入研發資源，遷移至 `Media3 Effect` 方案以達到最佳使用者體驗。
